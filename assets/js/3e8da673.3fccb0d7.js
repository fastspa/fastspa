"use strict";(globalThis.webpackChunkfastspa_documentation=globalThis.webpackChunkfastspa_documentation||[]).push([[668],{7042(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"api/ipf","title":"IPF (Iterative Proportional Fitting) API","description":"Fastspa provides comprehensive IPF functionality for adjusting IO tables, technical coefficients, and satellite data to match updated sector constraints while preserving underlying structure and cross-product ratios.","source":"@site/docs/api/ipf.md","sourceDirName":"api","slug":"/api/ipf","permalink":"/docs/api/ipf","draft":false,"unlisted":false,"editUrl":"https://docs.fastspa.net/edit/main/docs/docs/api/ipf.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Data Classes","permalink":"/docs/api/data-classes"}}');var a=s(6070),r=s(8193);const i={},l="IPF (Iterative Proportional Fitting) API",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Classes",id:"classes",level:2},{value:"IPFBalancer",id:"ipfbalancer",level:3},{value:"Methods",id:"methods",level:4},{value:"adjust_io_matrix()",id:"adjust_io_matrix",level:5},{value:"adjust_a_matrix()",id:"adjust_a_matrix",level:5},{value:"adjust_satellite_data()",id:"adjust_satellite_data",level:5},{value:"balance_multi_sector_data()",id:"balance_multi_sector_data",level:5},{value:"IPFResult",id:"ipfresult",level:3},{value:"Functions",id:"functions",level:2},{value:"adjust_io_table_with_concordance()",id:"adjust_io_table_with_concordance",level:3},{value:"Integration with SPA",id:"integration-with-spa",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Convergence Monitoring",id:"1-convergence-monitoring",level:3},{value:"2. Constraint Validation",id:"2-constraint-validation",level:3},{value:"3. Structure Preservation",id:"3-structure-preservation",level:3},{value:"4. Multi-dimensional Data",id:"4-multi-dimensional-data",level:3},{value:"5. Scenario Analysis",id:"5-scenario-analysis",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Input Validation",id:"input-validation",level:3},{value:"Convergence Issues",id:"convergence-issues",level:3},{value:"Numerical Stability",id:"numerical-stability",level:3},{value:"References",id:"references",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"ipf-iterative-proportional-fitting-api",children:"IPF (Iterative Proportional Fitting) API"})}),"\n",(0,a.jsx)(n.p,{children:"Fastspa provides comprehensive IPF functionality for adjusting IO tables, technical coefficients, and satellite data to match updated sector constraints while preserving underlying structure and cross-product ratios."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"IPF is widely used in EEIO analysis for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"IO table balancing"}),": Update transaction matrices to new sector outputs and uses"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Technical coefficients adjustment"}),": Modify A matrices while preserving relationships"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Satellite data scaling"}),": Adjust environmental data to match new constraints"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Scenario analysis"}),": Create realistic economic scenarios for policy analysis"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Based on the ipfn package and academic literature on iterative proportional fitting."}),"\n",(0,a.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,a.jsx)(n.h3,{id:"ipfbalancer",children:"IPFBalancer"}),"\n",(0,a.jsx)(n.p,{children:"Main class for performing IPF adjustments across various data types."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from fastspa import IPFBalancer\n\nbalancer = IPFBalancer()\n"})}),"\n",(0,a.jsx)(n.h4,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(n.h5,{id:"adjust_io_matrix",children:"adjust_io_matrix()"}),"\n",(0,a.jsx)(n.p,{children:"Adjust an IO transaction matrix to match new row and column totals."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"result = balancer.adjust_io_matrix(\n    io_matrix,\n    new_row_totals,\n    new_col_totals,\n    max_iterations=1000,\n    convergence_rate=1e-6,\n    rate_tolerance=0.0,\n    verbose=0\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"io_matrix"}),": Original transaction matrix (n\xd7n)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"new_row_totals"}),": Target row sums (outputs by sector)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"new_col_totals"}),": Target column sums (inputs by sector)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"max_iterations"}),": Maximum number of iterations (default: 1000)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convergence_rate"}),": Convergence tolerance (default: 1e-6)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"rate_tolerance"}),": Tolerance for early stopping based on rate change (default: 0.0)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"verbose"}),": Verbosity level (0=silent, 1=status, 2=detailed, default: 0)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," ",(0,a.jsx)(n.code,{children:"IPFResult"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom fastspa import IPFBalancer\n\n# Original IO matrix\nio_matrix = np.array([\n    [100, 50],\n    [30, 200]\n])\n\n# New sector totals\nnew_outputs = np.array([180, 250])  # New gross outputs\nnew_inputs = np.array([150, 280])   # New sector inputs\n\n# Apply IPF adjustment\nbalancer = IPFBalancer()\nresult = balancer.adjust_io_matrix(io_matrix, new_outputs, new_inputs)\n\nprint(f"Converged: {result.converged}")\nprint(f"Iterations: {result.iterations}")\nprint(f"Adjusted matrix:\\n{result.adjusted_matrix}")\n'})}),"\n",(0,a.jsx)(n.h5,{id:"adjust_a_matrix",children:"adjust_a_matrix()"}),"\n",(0,a.jsx)(n.p,{children:"Adjust technical coefficients matrix to new sector totals."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"result = balancer.adjust_a_matrix(\n    A_matrix,\n    new_row_totals,\n    new_col_totals=None,\n    preserve_structure=True,\n    max_iterations=1000,\n    convergence_rate=1e-6,\n    verbose=0\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"A_matrix"}),": Technical coefficients matrix (n\xd7n)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"new_row_totals"}),": Target sector outputs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"new_col_totals"}),": Target sector inputs (if None, uses row totals)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"preserve_structure"}),": Whether to preserve zero structure (default: True)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"max_iterations"}),": Maximum iterations (default: 1000)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convergence_rate"}),": Convergence tolerance (default: 1e-6)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"verbose"}),": Verbosity level (default: 0)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," ",(0,a.jsx)(n.code,{children:"IPFResult"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Technical coefficients matrix\nA_matrix = np.array([\n    [0.1, 0.05],\n    [0.03, 0.15]\n])\n\n# New gross outputs\nnew_outputs = np.array([1.2, 1.8])\n\n# Adjust A matrix\nresult = balancer.adjust_a_matrix(A_matrix, new_outputs, preserve_structure=True)\n"})}),"\n",(0,a.jsx)(n.h5,{id:"adjust_satellite_data",children:"adjust_satellite_data()"}),"\n",(0,a.jsx)(n.p,{children:"Adjust satellite data (emissions, resource use) to new sector totals."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"result = balancer.adjust_satellite_data(\n    satellite_data,\n    new_totals,\n    dimensions=None,\n    max_iterations=1000,\n    convergence_rate=1e-6\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"satellite_data"}),": Satellite data array (1D, 2D, or 3D)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"new_totals"}),": Target totals along specified dimensions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dimensions"}),": Which dimensions to constrain (default: [0])"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"max_iterations"}),": Maximum iterations (default: 1000)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convergence_rate"}),": Convergence tolerance (default: 1e-6)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," ",(0,a.jsx)(n.code,{children:"IPFResult"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,a.jsx)(n.p,{children:"1D satellite data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Emissions by sector\nemissions = np.array([100, 50, 80, 30])\nnew_targets = np.array([120, 60, 95, 35])\n\nresult = balancer.adjust_satellite_data(emissions, [new_targets])\n"})}),"\n",(0,a.jsx)(n.p,{children:"2D satellite data (by sector and region):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Emissions by sector and region\nemissions_2d = np.array([\n    [100, 50, 80],   # Region A\n    [60, 120, 40],   # Region B\n    [80, 30, 100]    # Region C\n])\n\n# New totals by sector (sum over regions)\nsector_totals = np.array([260, 220, 200])\n\nresult = balancer.adjust_satellite_data(\n    emissions_2d, \n    [sector_totals],\n    dimensions=[1]  # Sum over regions\n)\n"})}),"\n",(0,a.jsx)(n.h5,{id:"balance_multi_sector_data",children:"balance_multi_sector_data()"}),"\n",(0,a.jsx)(n.p,{children:"Balance multiple related data matrices simultaneously."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"results = balancer.balance_multi_sector_data(\n    data_matrices,\n    constraints,\n    max_iterations=1000,\n    convergence_rate=1e-6\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"data_matrices"}),": Dict mapping names to matrices to adjust"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"constraints"}),": Dict mapping matrix names to constraint dicts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"max_iterations"}),": Maximum iterations (default: 1000)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convergence_rate"}),": Convergence tolerance (default: 1e-6)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," Dict[str, IPFResult]"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Multiple satellite matrices\nmatrices = {\n    'GHG': np.array([[100, 50], [30, 200]]),\n    'Water': np.array([[80, 40], [25, 160]]),\n    'Energy': np.array([[120, 60], [35, 240]])\n}\n\n# Constraints for each matrix\nconstraints = {\n    'GHG': {\n        'rows': np.array([180, 250]),  # New GHG totals by sector\n        'cols': np.array([150, 280])   # New sector inputs\n    },\n    'Water': {\n        'rows': np.array([140, 200]),  # New water use by sector\n        'cols': np.array([120, 220])\n    },\n    'Energy': {\n        'rows': np.array([200, 320]),  # New energy use by sector\n        'cols': np.array([180, 340])\n    }\n}\n\n# Balance all matrices\nresults = balancer.balance_multi_sector_data(matrices, constraints)\n\n# Access results\nghg_result = results['GHG']\nwater_result = results['Water']\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ipfresult",children:"IPFResult"}),"\n",(0,a.jsx)(n.p,{children:"Dataclass containing results from IPF adjustment operations."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"@dataclass\nclass IPFResult:\n    adjusted_matrix: NDArray\n    original_matrix: NDArray\n    iterations: int\n    convergence_rate: float\n    converged: bool\n    row_constraints: NDArray\n    col_constraints: NDArray\n    relative_entropy: float\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"adjusted_matrix"}),": Final adjusted matrix after IPF convergence"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"original_matrix"}),": Original input matrix"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"iterations"}),": Number of iterations taken to converge"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convergence_rate"}),": Final convergence rate"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"converged"}),": Whether algorithm converged within max_iterations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"row_constraints"}),": Target row sums that were applied"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"col_constraints"}),": Target column sums that were applied"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"relative_entropy"}),": Relative entropy distance from original to adjusted"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'result = balancer.adjust_io_matrix(io_matrix, new_outputs, new_inputs)\n\nprint(f"Convergence: {\'\u2713\' if result.converged else \'\u2717\'}")\nprint(f"Iterations: {result.iterations}")\nprint(f"Final rate: {result.convergence_rate:.2e}")\nprint(f"Relative entropy: {result.relative_entropy:.4f}")\n\n# Verify constraints\nadjusted_outputs = result.adjusted_matrix.sum(axis=1)\nnp.testing.assert_allclose(adjusted_outputs, result.row_constraints, rtol=1e-5)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,a.jsx)(n.h3,{id:"adjust_io_table_with_concordance",children:"adjust_io_table_with_concordance()"}),"\n",(0,a.jsx)(n.p,{children:"Adjust IO table using sector concordance to target totals."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"adjusted_io, result = adjust_io_table_with_concordance(\n    io_matrix,\n    concordance_matrix,\n    target_sector_totals,\n    max_iterations=1000,\n    convergence_rate=1e-6\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"io_matrix"}),": Original IO matrix in source classification"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"concordance_matrix"}),": Mapping from source to target sectors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"target_sector_totals"}),": Target totals in target classification"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"max_iterations"}),": Maximum IPF iterations (default: 1000)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convergence_rate"}),": Convergence tolerance (default: 1e-6)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," Tuple[NDArray, IPFResult]"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from fastspa import adjust_io_table_with_concordance\n\n# Original IO table in ANZSIC classification\nio_anzsic = np.array([\n    [100, 30, 20],\n    [25, 200, 40],\n    [15, 35, 150]\n])\n\n# Concordance: ANZSIC \u2192 IOIG\nconcordance = np.array([\n    [0.8, 0.2],  # ANZSIC 1 \u2192 80% IOIG 1, 20% IOIG 2\n    [0.3, 0.7],  # ANZSIC 2 \u2192 30% IOIG 1, 70% IOIG 2\n    [0.1, 0.9]   # ANZSIC 3 \u2192 10% IOIG 1, 90% IOIG 2\n])\n\n# Target totals in IOIG classification\ntarget_ioig_totals = np.array([300, 450])\n\n# Apply adjustment\nadjusted_io, result = adjust_io_table_with_concordance(\n    io_anzsic, concordance, target_ioig_totals\n)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-spa",children:"Integration with SPA"}),"\n",(0,a.jsx)(n.p,{children:"IPF functionality integrates seamlessly with SPA analysis for scenario-based environmental assessment:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from fastspa import SPA, IPFBalancer\n\n# Step 1: Create baseline SPA\nspa_baseline = SPA(A_baseline, emissions, sector_names)\nbaseline_paths = spa_baseline.analyze(\'Manufacturing\', depth=5)\n\n# Step 2: Create scenario with IPF\nbalancer = IPFBalancer()\nA_result = balancer.adjust_a_matrix(A_baseline, new_outputs)\nemissions_result = balancer.adjust_satellite_data(emissions, new_emissions)\n\n# Step 3: Run SPA on adjusted data\nspa_scenario = SPA(A_result.adjusted_matrix, emissions_result.adjusted_matrix, sector_names)\nscenario_paths = spa_scenario.analyze(\'Manufacturing\', depth=5)\n\n# Step 4: Compare scenarios\nprint(f"Baseline intensity: {baseline_paths.total_intensity:.4f}")\nprint(f"Scenario intensity: {scenario_paths.total_intensity:.4f}")\nchange = (scenario_paths.total_intensity - baseline_paths.total_intensity) / baseline_paths.total_intensity * 100\nprint(f"Change: {change:+.1f}%")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-convergence-monitoring",children:"1. Convergence Monitoring"}),"\n",(0,a.jsx)(n.p,{children:"Always check convergence status and convergence rate:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'result = balancer.adjust_io_matrix(io_matrix, new_outputs, new_inputs)\n\nif not result.converged:\n    print(f"Warning: IPF did not converge after {result.iterations} iterations")\n    print(f"Final convergence rate: {result.convergence_rate:.2e}")\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-constraint-validation",children:"2. Constraint Validation"}),"\n",(0,a.jsx)(n.p,{children:"Verify that constraints are satisfied:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Check row constraints\nactual_rows = result.adjusted_matrix.sum(axis=1)\nnp.testing.assert_allclose(actual_rows, result.row_constraints, rtol=1e-5)\n\n# Check column constraints\nactual_cols = result.adjusted_matrix.sum(axis=0)\nnp.testing.assert_allclose(actual_cols, result.col_constraints, rtol=1e-5)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-structure-preservation",children:"3. Structure Preservation"}),"\n",(0,a.jsxs)(n.p,{children:["For A matrices, use ",(0,a.jsx)(n.code,{children:"preserve_structure=True"})," to maintain zero elements:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"result = balancer.adjust_a_matrix(A_matrix, new_outputs, preserve_structure=True)\n\n# Verify zero structure is preserved\nzero_mask = (A_matrix == 0)\nassert np.all(result.adjusted_matrix[zero_mask] == 0)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-multi-dimensional-data",children:"4. Multi-dimensional Data"}),"\n",(0,a.jsx)(n.p,{children:"For complex satellite data, carefully specify dimensions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# For 3D data (sector \xd7 region \xd7 time)\nsatellite_3d = np.array([...])  # shape: (n_sectors, n_regions, n_years)\n\n# Constrain sector totals across regions and time\nsector_totals = np.array([...])  # shape: (n_sectors,)\n\nresult = balancer.adjust_satellite_data(\n    satellite_3d, \n    [sector_totals],\n    dimensions=[0]  # Sum over regions and time\n)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-scenario-analysis",children:"5. Scenario Analysis"}),"\n",(0,a.jsx)(n.p,{children:"Use IPF for realistic scenario creation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Green transition scenario\nnew_outputs = np.array([1.1, 0.9, 1.3])  # Sector growth rates\nnew_emissions = np.array([0.9, 0.7, 1.1])  # Emission intensity changes\n\n# Apply adjustments\nA_result = balancer.adjust_a_matrix(A_matrix, new_outputs)\nemissions_result = balancer.adjust_satellite_data(emissions, new_emissions)\n\n# Run comparative SPA analysis\n# ... (see integration example above)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.p,{children:"The IPF implementation includes comprehensive error handling:"}),"\n",(0,a.jsx)(n.h3,{id:"input-validation",children:"Input Validation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Matrix dimension checking"}),"\n",(0,a.jsx)(n.li,{children:"Constraint array size validation"}),"\n",(0,a.jsx)(n.li,{children:"Non-negative constraint verification"}),"\n",(0,a.jsx)(n.li,{children:"Concordance matrix normalization checks"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"convergence-issues",children:"Convergence Issues"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Automatic convergence monitoring"}),"\n",(0,a.jsx)(n.li,{children:"Detailed convergence metrics"}),"\n",(0,a.jsx)(n.li,{children:"Graceful handling of non-convergence"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"numerical-stability",children:"Numerical Stability"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Handling of zero and near-zero values"}),"\n",(0,a.jsx)(n.li,{children:"Numerical precision management"}),"\n",(0,a.jsx)(n.li,{children:"Relative entropy calculations"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsx)(n.p,{children:"The IPF implementation is based on:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Deming, W.E. & Stephan, F.F. (1940)"}),": Original IPF paper for contingency tables"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"R\xfcschendorf, L. (1995)"}),": Convergence properties of IPF under marginal constraints"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Norman, P. (1999)"}),": Practical IPF implementation guidelines"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ipfn package"}),": Python implementation of IPF algorithms"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For detailed mathematical foundations, see the academic references in the main fastspa documentation."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8193(e,n,s){s.d(n,{R:()=>i,x:()=>l});var t=s(758);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);