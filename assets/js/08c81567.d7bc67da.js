"use strict";(globalThis.webpackChunkfastspa_documentation=globalThis.webpackChunkfastspa_documentation||[]).push([[245],{935(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>g});const a=JSON.parse('{"id":"guides/semantic-aggregation","title":"Semantic Aggregation (Custom & Hierarchical)","description":"Structural paths are often too granular to communicate directly.","source":"@site/docs/guides/semantic-aggregation.md","sourceDirName":"guides","slug":"/guides/semantic-aggregation","permalink":"/docs/guides/semantic-aggregation","draft":false,"unlisted":false,"editUrl":"https://docs.fastspa.net/edit/main/docs/docs/guides/semantic-aggregation.md","tags":[],"version":"current","frontMatter":{"title":"Semantic Aggregation (Custom & Hierarchical)"},"sidebar":"tutorialSidebar","previous":{"title":"Loading Data","permalink":"/docs/guides/loading-data"},"next":{"title":"Network Analysis (Centrality & Bottlenecks)","permalink":"/docs/guides/network-analysis"}}');var s=t(6070),r=t(8193);const i={title:"Semantic Aggregation (Custom & Hierarchical)"},o=void 0,c={},g=[{value:"Custom sector grouping",id:"custom-sector-grouping",level:2},{value:"Hierarchical aggregation",id:"hierarchical-aggregation",level:2},{value:"Notes",id:"notes",level:2}];function l(e){const n={code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Structural paths are often too granular to communicate directly.\nfastspa supports post-processing aggregation of results into semantic groups."}),"\n",(0,s.jsx)(n.h2,{id:"custom-sector-grouping",children:"Custom sector grouping"}),"\n",(0,s.jsx)(n.p,{children:"Aggregate by leaf (emission source sector) into user-defined groups:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'paths = spa.analyze(sector=42, depth=8)\n\nmapping = {\n    0: "Primary",\n    1: "Secondary",\n    2: "Services",\n}\n\nby_group = paths.semantic_aggregate(mapping)\n'})}),"\n",(0,s.jsx)(n.p,{children:"If sector names were provided, mappings can also be name-based:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'mapping = {\n    "Agriculture": "Primary",\n    "Manufacturing": "Secondary",\n    "Services": "Services",\n}\nby_group = paths.semantic_aggregate(mapping)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"hierarchical-aggregation",children:"Hierarchical aggregation"}),"\n",(0,s.jsx)(n.p,{children:"Provide multiple mappings to build multi-level group keys:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'level_1 = {0: "Goods", 1: "Goods", 2: "Services"}\nlevel_2 = {0: "Agriculture", 1: "Manufacturing", 2: "Services"}\n\nhier = paths.hierarchical_aggregate([level_1, level_2])\n# keys look like: ("Goods", "Manufacturing")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Aggregation is a ",(0,s.jsx)(n.em,{children:"post-processing"})," step: it does not change SPA traversal."]}),"\n",(0,s.jsxs)(n.li,{children:["By default, aggregation uses the ",(0,s.jsx)(n.strong,{children:"leaf sector"}),"; you can also aggregate by other stages."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8193(e,n,t){t.d(n,{R:()=>i,x:()=>o});var a=t(758);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);