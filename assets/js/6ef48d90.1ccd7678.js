"use strict";(globalThis.webpackChunkfastspa_documentation=globalThis.webpackChunkfastspa_documentation||[]).push([[209],{3540(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"guides/streaming","title":"Memory-Efficient Streaming","description":"For large systems, stream paths without collecting all in memory.","source":"@site/docs/guides/streaming.md","sourceDirName":"guides","slug":"/guides/streaming","permalink":"/docs/guides/streaming","draft":false,"unlisted":false,"editUrl":"https://docs.fastspa.net/edit/main/docs/docs/guides/streaming.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Sector Concordance","permalink":"/docs/guides/concordance"},"next":{"title":"Loading Data","permalink":"/docs/guides/loading-data"}}');var s=n(6070),i=n(8193);const a={sidebar_position:3},o="Memory-Efficient Streaming",c={},d=[{value:"Basic Streaming",id:"basic-streaming",level:2},{value:"Key Differences from <code>analyze()</code>",id:"key-differences-from-analyze",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Large Systems",id:"large-systems",level:3},{value:"Early Termination",id:"early-termination",level:3},{value:"Real-Time Processing",id:"real-time-processing",level:3},{value:"Custom Aggregation",id:"custom-aggregation",level:3},{value:"Parameters",id:"parameters",level:2},{value:"Combining with PathCollection",id:"combining-with-pathcollection",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"memory-efficient-streaming",children:"Memory-Efficient Streaming"})}),"\n",(0,s.jsx)(t.p,{children:"For large systems, stream paths without collecting all in memory."}),"\n",(0,s.jsx)(t.h2,{id:"basic-streaming",children:"Basic Streaming"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"stream()"})," instead of ",(0,s.jsx)(t.code,{children:"analyze()"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"for path in spa.stream(sector=42, depth=12, threshold=1e-9):\r\n    if path.contribution > 0.001:\r\n        process(path)\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"key-differences-from-analyze",children:["Key Differences from ",(0,s.jsx)(t.code,{children:"analyze()"})]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Aspect"}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.code,{children:"analyze()"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.code,{children:"stream()"})})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Returns"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PathCollection"})}),(0,s.jsxs)(t.td,{children:["Iterator of ",(0,s.jsx)(t.code,{children:"Path"})]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Memory"}),(0,s.jsx)(t.td,{children:"Loads all paths"}),(0,s.jsx)(t.td,{children:"One path at a time"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Order"}),(0,s.jsx)(t.td,{children:"Sorted by contribution"}),(0,s.jsx)(t.td,{children:"Discovery order"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Features"}),(0,s.jsx)(t.td,{children:"Filtering, aggregation"}),(0,s.jsx)(t.td,{children:"Manual processing"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsx)(t.h3,{id:"large-systems",children:"Large Systems"}),"\n",(0,s.jsx)(t.p,{children:"When the number of paths exceeds available memory:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# System with 10,000+ sectors\r\nspa = SPA(large_A_matrix, intensities)\r\n\r\n# Stream instead of loading all\r\nsignificant_paths = []\r\nfor path in spa.stream(sector=1, depth=15, threshold=1e-12):\r\n    if path.contribution > 0.0001:\r\n        significant_paths.append(path)\r\n\r\nprint(f"Found {len(significant_paths)} significant paths")\n'})}),"\n",(0,s.jsx)(t.h3,{id:"early-termination",children:"Early Termination"}),"\n",(0,s.jsx)(t.p,{children:"Stop processing when you have enough:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'top_paths = []\r\nfor path in spa.stream(sector=42, depth=10):\r\n    if path.contribution > 0.01:\r\n        top_paths.append(path)\r\n    if len(top_paths) >= 100:\r\n        break  # Stop early\r\n\r\nprint(f"Collected {len(top_paths)} paths with >1% contribution")\n'})}),"\n",(0,s.jsx)(t.h3,{id:"real-time-processing",children:"Real-Time Processing"}),"\n",(0,s.jsx)(t.p,{children:"Process paths as they're discovered:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import csv\r\n\r\nwith open("paths.csv", "w", newline="") as f:\r\n    writer = csv.writer(f)\r\n    writer.writerow(["contribution", "path", "depth"])\r\n\r\n    for path in spa.stream(sector=42, depth=8):\r\n        writer.writerow([\r\n            f"{path.contribution:.6f}",\r\n            " \u2192 ".join(path.sectors),\r\n            path.depth\r\n        ])\n'})}),"\n",(0,s.jsx)(t.h3,{id:"custom-aggregation",children:"Custom Aggregation"}),"\n",(0,s.jsx)(t.p,{children:"Build custom aggregations without storing all paths:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from collections import defaultdict\r\n\r\n# Count paths by depth\r\ndepth_counts = defaultdict(int)\r\ndepth_contributions = defaultdict(float)\r\n\r\nfor path in spa.stream(sector=42, depth=10):\r\n    depth_counts[path.depth] += 1\r\n    depth_contributions[path.depth] += path.contribution\r\n\r\nfor depth in sorted(depth_counts.keys()):\r\n    print(f"Depth {depth}: {depth_counts[depth]} paths, "\r\n          f"{depth_contributions[depth]:.2%} contribution")\n'})}),"\n",(0,s.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"stream()"})," accepts most of the same parameters as ",(0,s.jsx)(t.code,{children:"analyze()"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'spa.stream(\r\n    sector=42,           # Target sector (required)\r\n    depth=8,             # Maximum depth (default: 8)\r\n    threshold=0.001,     # Minimum threshold (default: 0.001)\r\n    threshold_type="percentage",  # or "absolute"\r\n    satellite="ghg",     # Which satellite to analyze\r\n)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"combining-with-pathcollection",children:"Combining with PathCollection"}),"\n",(0,s.jsx)(t.p,{children:"If you need PathCollection features after streaming:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from fastspa import PathCollection\r\n\r\n# Stream and collect significant paths\r\npaths_list = [\r\n    path for path in spa.stream(sector=42, depth=10)\r\n    if path.contribution > 0.001\r\n]\r\n\r\n# Create PathCollection manually\r\npaths = PathCollection(\r\n    paths=paths_list,\r\n    target_sector=42,\r\n    total_intensity=spa.total_intensity()[42],\r\n    satellite_name="intensity",\r\n)\r\n\r\n# Now use PathCollection features\r\ndf = paths.to_dataframe()\n'})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8193(e,t,n){n.d(t,{R:()=>a,x:()=>o});var r=n(758);const s={},i=r.createContext(s);function a(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);