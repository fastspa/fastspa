"use strict";(globalThis.webpackChunkfastspa_documentation=globalThis.webpackChunkfastspa_documentation||[]).push([[434],{8193(e,t,s){s.d(t,{R:()=>a,x:()=>r});var n=s(758);const o={},i=n.createContext(o);function a(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(i.Provider,{value:t},e.children)}},8984(e,t,s){s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"guides/loop-analysis","title":"Loop Detection & Circular Economy Analysis","description":"In system-wide (Leontief) mode, circular flows are represented implicitly.","source":"@site/docs/guides/loop-analysis.md","sourceDirName":"guides","slug":"/guides/loop-analysis","permalink":"/docs/guides/loop-analysis","draft":false,"unlisted":false,"editUrl":"https://docs.fastspa.net/edit/main/docs/docs/guides/loop-analysis.md","tags":[],"version":"current","frontMatter":{"title":"Loop Detection & Circular Economy Analysis"},"sidebar":"tutorialSidebar","previous":{"title":"Temporal Analysis (Multi-year & Dynamic SPA)","permalink":"/docs/guides/temporal-analysis"},"next":{"title":"Visualization Guide","permalink":"/docs/guides/visualization"}}');var o=s(6070),i=s(8193);const a={title:"Loop Detection & Circular Economy Analysis"},r=void 0,l={},c=[{value:"Detect loops in extracted paths",id:"detect-loops-in-extracted-paths",level:2},{value:"Interpretation",id:"interpretation",level:2},{value:"Feedback loop metrics",id:"feedback-loop-metrics",level:2}];function p(e){const t={code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In system-wide (Leontief) mode, circular flows are represented implicitly.\nfastspa also supports explicit loop detection on the extracted path set."}),"\n",(0,o.jsx)(t.h2,{id:"detect-loops-in-extracted-paths",children:"Detect loops in extracted paths"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'paths = spa.analyze(sector=42, depth=8)\n\nloops = paths.loop_analysis()\n\nprint("Loop share:", loops.loop_share)\nprint("Top cycles:", loops.top_cycles(10))\n'})}),"\n",(0,o.jsx)(t.h2,{id:"interpretation",children:"Interpretation"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["A ",(0,o.jsx)(t.em,{children:"loop"})," is detected when a sector index repeats within a single path."]}),"\n",(0,o.jsx)(t.li,{children:"The analysis summarises each looping path using the first repeated sector encountered."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"feedback-loop-metrics",children:"Feedback loop metrics"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"loops.sector_participation"})," provides a per-sector measure of participation in looping paths.\nThis can be useful as a proxy for self-reinforcing circular dynamics."]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}}}]);