"use strict";(globalThis.webpackChunkfastspa_documentation=globalThis.webpackChunkfastspa_documentation||[]).push([[826],{3268(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/sector-adjustments","title":"Sector Adjustments with IPF","description":"This guide explains how to use Iterative Proportional Fitting (IPF) to adjust IO tables, technical coefficients, and satellite data for scenario analysis in EEIO models.","source":"@site/docs/guides/sector-adjustments.md","sourceDirName":"guides","slug":"/guides/sector-adjustments","permalink":"/docs/guides/sector-adjustments","draft":false,"unlisted":false,"editUrl":"https://docs.fastspa.net/edit/main/docs/docs/guides/sector-adjustments.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Visualization Guide","permalink":"/docs/guides/visualization"},"next":{"title":"SPA Class","permalink":"/docs/api/spa-class"}}');var i=s(6070),a=s(8193);const r={},o="Sector Adjustments with IPF",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"When to Use IPF",id:"when-to-use-ipf",level:2},{value:"Use IPF when you need to:",id:"use-ipf-when-you-need-to",level:3},{value:"Consider alternatives when:",id:"consider-alternatives-when",level:3},{value:"Theoretical Context",id:"theoretical-context",level:2},{value:"RAS vs. IPF in EEIO",id:"ras-vs-ipf-in-eeio",level:3},{value:"Basic IPF Workflow",id:"basic-ipf-workflow",level:2},{value:"Step-by-Step Examples",id:"step-by-step-examples",level:2},{value:"Example 1: Adjusting an IO Table",id:"example-1-adjusting-an-io-table",level:3},{value:"Example 2: Adjusting Technical Coefficients",id:"example-2-adjusting-technical-coefficients",level:3},{value:"Example 3: Adjusting Satellite Data",id:"example-3-adjusting-satellite-data",level:3},{value:"Example 4: Multi-dimensional Satellite Data",id:"example-4-multi-dimensional-satellite-data",level:3},{value:"Example 5: Scenario Analysis with SPA",id:"example-5-scenario-analysis-with-spa",level:3},{value:"Advanced Techniques",id:"advanced-techniques",level:2},{value:"Balancing Multiple Matrices",id:"balancing-multiple-matrices",level:3},{value:"Using Sector Concordance",id:"using-sector-concordance",level:3},{value:"Validation and Quality Checks",id:"validation-and-quality-checks",level:2},{value:"Convergence Monitoring",id:"convergence-monitoring",level:3},{value:"Constraint Verification",id:"constraint-verification",level:3},{value:"Reasonableness Checks",id:"reasonableness-checks",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"1. Non-Convergence",id:"1-non-convergence",level:3},{value:"2. Inconsistent Constraints",id:"2-inconsistent-constraints",level:3},{value:"3. Zero Structure Issues",id:"3-zero-structure-issues",level:3},{value:"4. Numerical Precision",id:"4-numerical-precision",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Integration with Other FastSPA Features",id:"integration-with-other-fastspa-features",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"sector-adjustments-with-ipf",children:"Sector Adjustments with IPF"})}),"\n",(0,i.jsx)(n.p,{children:"This guide explains how to use Iterative Proportional Fitting (IPF) to adjust IO tables, technical coefficients, and satellite data for scenario analysis in EEIO models."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"IPF is a powerful mathematical technique for adjusting economic and environmental data to match new constraints while preserving the underlying structure and relationships. In EEIO analysis, it's commonly used for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Economic scenario analysis"}),": Updating IO tables to reflect policy changes or economic projections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Technology transitions"}),": Adjusting technical coefficients for new technologies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Environmental targets"}),": Scaling satellite data to meet emission reduction goals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-classification adjustments"}),": Mapping data between different sector classifications"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-ipf",children:"When to Use IPF"}),"\n",(0,i.jsx)(n.h3,{id:"use-ipf-when-you-need-to",children:"Use IPF when you need to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Update IO tables"})," to new economic output totals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Adjust A matrices"})," while preserving input-output relationships"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scale satellite data"})," to match new environmental constraints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create realistic scenarios"})," with preserved economic structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Balance multiple matrices"})," simultaneously with shared constraints"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"consider-alternatives-when",children:"Consider alternatives when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You have perfect data with no adjustment needs"}),"\n",(0,i.jsx)(n.li,{children:"Constraints are so extreme they violate economic logic"}),"\n",(0,i.jsx)(n.li,{children:"The system is highly non-linear (IPF works best with proportional relationships)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"theoretical-context",children:"Theoretical Context"}),"\n",(0,i.jsx)(n.h3,{id:"ras-vs-ipf-in-eeio",children:"RAS vs. IPF in EEIO"}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.strong,{children:"mathematically identical"})," (RAS is simply the 2D application of IPF), they are often distinguished by their scope in EEIO:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"RAS (Biproportional Scaling)"}),": The standard method for ",(0,i.jsx)(n.strong,{children:"balancing IO tables"})," (transaction matrices). It iteratively scales rows and columns to match new total output/input constraints while preserving the original structure (technological coefficients). It is simple, fast, and ideal for national table updates."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"IPF (Iterative Proportional Fitting)"}),": Used for ",(0,i.jsx)(n.strong,{children:"multi-dimensional constraints"})," and more complex tasks. It handles situations beyond just row/column totals, such as regionalizing tables, disaggregating sectors, or adjusting multi-regional supply chain data where constraints exist across multiple dimensions (e.g., sectors \xd7 regions \xd7 emissions, trade margins, employment vectors)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sector Adjustments"}),": For simple changes to specific coefficients (e.g., a technology shock), direct modification of the A-matrix is often sufficient. However, if this change must be consistent with new system-wide totals, RAS/IPF is required to re-balance the economy."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-ipf-workflow",children:"Basic IPF Workflow"}),"\n",(0,i.jsx)(n.p,{children:"The typical IPF workflow involves:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prepare baseline data"})," (IO matrix, A matrix, or satellite data)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Define target constraints"})," (new sector totals, emission targets, etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Apply IPF adjustment"})," using the appropriate method"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validate results"})," (convergence, constraint satisfaction, reasonableness)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use adjusted data"})," in downstream analysis (SPA, hotspots, etc.)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"step-by-step-examples",children:"Step-by-Step Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-1-adjusting-an-io-table",children:"Example 1: Adjusting an IO Table"}),"\n",(0,i.jsx)(n.p,{children:"Suppose we have a 3-sector economy and want to model a green transition where services grow while manufacturing shrinks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom fastspa import IPFBalancer\n\n# Original IO transaction matrix\nio_matrix = np.array([\n    [100,  50,  30],   # Agriculture\n    [ 40, 200,  60],   # Manufacturing  \n    [ 20,  80, 150]    # Services\n])\n\n# Scenario: Services +30%, Manufacturing -10%, Agriculture +10%\nbaseline_totals = io_matrix.sum(axis=1)  # [180, 300, 250]\nnew_totals = baseline_totals * np.array([1.1, 0.9, 1.3])  # [198, 270, 325]\n\nprint(f"Baseline totals: {baseline_totals}")\nprint(f"Scenario totals: {new_totals}")\n\n# Apply IPF adjustment\nbalancer = IPFBalancer()\nresult = balancer.adjust_io_matrix(\n    io_matrix, \n    new_totals,  # Row constraints (outputs)\n    new_totals   # Column constraints (inputs - assume symmetric)\n)\n\nprint(f"\\\\nAdjustment results:")\nprint(f"Converged: {result.converged}")\nprint(f"Iterations: {result.iterations}")\nprint(f"Convergence rate: {result.convergence_rate:.2e}")\n\n# Verify constraints\nactual_outputs = result.adjusted_matrix.sum(axis=1)\nprint(f"\\\\nConstraint verification:")\nprint(f"Target outputs: {new_totals}")\nprint(f"Actual outputs: {actual_outputs}")\nprint(f"Difference: {abs(actual_outputs - new_totals).max():.2e}")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-2-adjusting-technical-coefficients",children:"Example 2: Adjusting Technical Coefficients"}),"\n",(0,i.jsx)(n.p,{children:"For SPA analysis, we often need to adjust the A matrix (technical coefficients) to reflect new economic structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Technical coefficients matrix\nA_matrix = np.array([\n    [0.10, 0.05, 0.02],  # Agriculture inputs\n    [0.03, 0.15, 0.08],  # Manufacturing inputs\n    [0.02, 0.07, 0.12]   # Services inputs\n])\n\n# Scenario: Change in gross outputs\nnew_gross_outputs = np.array([1.2, 0.8, 1.4])  # Agriculture +20%, Manufacturing -20%, Services +40%\n\n# Adjust A matrix while preserving structure\nA_result = balancer.adjust_a_matrix(\n    A_matrix,\n    new_gross_outputs,\n    preserve_structure=True  # Maintain zero elements\n)\n\nprint(f"\\\\nA matrix adjustment:")\nprint(f"Original A matrix:\\\\n{A_matrix}")\nprint(f"Adjusted A matrix:\\\\n{A_result.adjusted_matrix}")\n\n# Check that zero structure is preserved\nzero_mask = (A_matrix == 0)\nprint(f"Zero structure preserved: {np.all(A_result.adjusted_matrix[zero_mask] == 0)}")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-3-adjusting-satellite-data",children:"Example 3: Adjusting Satellite Data"}),"\n",(0,i.jsx)(n.p,{children:"Environmental satellite data (emissions, water use, etc.) can be adjusted to reflect technology changes or policy targets:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# GHG emissions by sector (kg CO2-eq per unit output)\nemissions = np.array([0.5, 2.1, 0.8])  # Agriculture, Manufacturing, Services\n\n# Scenario: Technology improvements reduce manufacturing emissions by 30%\nnew_emissions = emissions.copy()\nnew_emissions[1] *= 0.7  # Manufacturing emissions reduced by 30%\n\nprint(f"\\\\nSatellite data adjustment:")\nprint(f"Original emissions: {emissions}")\nprint(f"Target emissions: {new_emissions}")\n\n# Apply IPF to satellite data\nemissions_result = balancer.adjust_satellite_data(emissions, [new_emissions])\n\nprint(f"Adjusted emissions: {emissions_result.adjusted_matrix}")\nprint(f"Total emissions preserved: {emissions_result.adjusted_matrix.sum():.3f} (original: {emissions.sum():.3f})")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-4-multi-dimensional-satellite-data",children:"Example 4: Multi-dimensional Satellite Data"}),"\n",(0,i.jsx)(n.p,{children:"For more complex data (e.g., emissions by sector and region), IPF can handle multi-dimensional arrays:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# 2D emissions data: sectors \xd7 regions\nemissions_2d = np.array([\n    [100,  50,  80],   # Region A: Agriculture, Manufacturing, Services\n    [ 60, 120,  40],   # Region B\n    [ 80,  30, 100]    # Region C\n])\n\n# Scenario: National emission targets by sector\nsector_targets = np.array([260, 220, 200])  # Total emissions by sector across all regions\n\nprint(f"\\\\nMulti-dimensional adjustment:")\nprint(f"Original emissions by sector and region:\\\\n{emissions_2d}")\nprint(f"Sector targets: {sector_targets}")\n\n# Adjust to meet sector targets (sum over regions)\nemissions_2d_result = balancer.adjust_satellite_data(\n    emissions_2d,\n    [sector_targets],\n    dimensions=[0]  # Sum over regions (dimension 0)\n)\n\nprint(f"Adjusted emissions:\\\\n{emissions_2d_result.adjusted_matrix}")\n\n# Verify sector totals\nadjusted_sector_totals = emissions_2d_result.adjusted_matrix.sum(axis=0)\nprint(f"\\\\nSector totals verification:")\nprint(f"Target: {sector_targets}")\nprint(f"Actual: {adjusted_sector_totals}")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-5-scenario-analysis-with-spa",children:"Example 5: Scenario Analysis with SPA"}),"\n",(0,i.jsx)(n.p,{children:"The most powerful use case is combining IPF adjustments with SPA analysis to study environmental impacts under different scenarios:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fastspa import SPA\n\n# Define sector names for interpretation\nsector_names = [\'Agriculture\', \'Manufacturing\', \'Services\']\n\n# Step 1: Create baseline SPA\nspa_baseline = SPA(A_matrix, emissions, sector_names)\nbaseline_results = spa_baseline.analyze(\'Manufacturing\', depth=5)\n\nprint(f"\\\\n=== Scenario Analysis ===")\nprint(f"\\\\nBaseline Analysis (Manufacturing sector):")\nprint(f"Total GHG intensity: {baseline_results.total_intensity:.4f}")\nprint(f"Number of significant pathways: {len(baseline_results.paths)}")\n\n# Step 2: Create scenario data\nscenario_gross_outputs = np.array([1.1, 0.9, 1.3])  # Green transition scenario\nscenario_emissions_factor = np.array([0.9, 0.7, 1.1])  # Technology improvements\n\n# Apply adjustments\nA_scenario_result = balancer.adjust_a_matrix(A_matrix, scenario_gross_outputs)\nemissions_scenario = emissions * scenario_emissions_factor\nemissions_scenario_result = balancer.adjust_satellite_data(emissions, [emissions_scenario])\n\n# Step 3: Run SPA on scenario data\nspa_scenario = SPA(\n    A_scenario_result.adjusted_matrix,\n    emissions_scenario_result.adjusted_matrix,\n    sector_names\n)\nscenario_results = spa_scenario.analyze(\'Manufacturing\', depth=5)\n\nprint(f"\\\\nScenario Analysis (Manufacturing sector):")\nprint(f"Total GHG intensity: {scenario_results.total_intensity:.4f}")\nprint(f"Number of significant pathways: {len(scenario_results.paths)}")\n\n# Step 4: Compare scenarios\nchange_pct = (scenario_results.total_intensity - baseline_results.total_intensity) / baseline_results.total_intensity * 100\nprint(f"\\\\nScenario Impact:")\nprint(f"Change in GHG intensity: {change_pct:+.1f}%")\n\n# Show top pathways comparison\nprint(f"\\\\nTop 3 pathways - Baseline:")\nfor i, path in enumerate(baseline_results.top(3)):\n    print(f"  {i+1}. {path}")\n\nprint(f"\\\\nTop 3 pathways - Scenario:")\nfor i, path in enumerate(scenario_results.top(3)):\n    print(f"  {i+1}. {path}")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-techniques",children:"Advanced Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"balancing-multiple-matrices",children:"Balancing Multiple Matrices"}),"\n",(0,i.jsx)(n.p,{children:"When you have multiple related matrices (e.g., different satellite accounts) that should be adjusted consistently:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Multiple satellite accounts\nmatrices = {\n    'GHG': np.array([[100, 50], [30, 200]]),\n    'Water': np.array([[80, 40], [25, 160]]),\n    'Energy': np.array([[120, 60], [35, 240]])\n}\n\n# Constraints for each matrix\nconstraints = {\n    'GHG': {\n        'rows': np.array([180, 250]),  # New GHG totals by sector\n        'cols': np.array([150, 280])\n    },\n    'Water': {\n        'rows': np.array([140, 200]),  # New water use by sector  \n        'cols': np.array([120, 220])\n    },\n    'Energy': {\n        'rows': np.array([200, 320]),  # New energy use by sector\n        'cols': np.array([180, 340])\n    }\n}\n\n# Balance all matrices simultaneously\nresults = balancer.balance_multi_sector_data(matrices, constraints)\n\n# Access adjusted matrices\nghg_adjusted = results['GHG'].adjusted_matrix\nwater_adjusted = results['Water'].adjusted_matrix\nenergy_adjusted = results['Energy'].adjusted_matrix\n\nprint(f\"All matrices balanced consistently:\")\nprint(f\"GHG converged: {results['GHG'].converged}\")\nprint(f\"Water converged: {results['Water'].converged}\")\nprint(f\"Energy converged: {results['Energy'].converged}\")\n"})}),"\n",(0,i.jsx)(n.h3,{id:"using-sector-concordance",children:"Using Sector Concordance"}),"\n",(0,i.jsx)(n.p,{children:"When you need to adjust data between different sector classifications:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fastspa import adjust_io_table_with_concordance\n\n# Original IO table in detailed classification (e.g., ANZSIC)\nio_detailed = np.array([\n    [100, 30, 20, 10],   # 4 detailed sectors\n    [25, 200, 40, 15],\n    [15, 35, 150, 25],\n    [10, 20, 30, 80]\n])\n\n# Concordance to simplified classification (e.g., IOIG)\nconcordance = np.array([\n    [1.0, 0.0],  # Sector 1 \u2192 Primary only\n    [0.8, 0.2],  # Sector 2 \u2192 80% Primary, 20% Secondary\n    [0.3, 0.7],  # Sector 3 \u2192 30% Primary, 70% Secondary\n    [0.1, 0.9]   # Sector 4 \u2192 10% Primary, 90% Secondary\n])\n\n# Target totals in simplified classification\ntarget_simplified_totals = np.array([300, 450])\n\n# Adjust IO table using concordance\nadjusted_io, result = adjust_io_table_with_concordance(\n    io_detailed, \n    concordance, \n    target_simplified_totals\n)\n\nprint(f"IO table adjusted from detailed to simplified classification")\nprint(f"Converged: {result.converged}")\nprint(f"Adjusted matrix shape: {adjusted_io.shape}")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"validation-and-quality-checks",children:"Validation and Quality Checks"}),"\n",(0,i.jsx)(n.h3,{id:"convergence-monitoring",children:"Convergence Monitoring"}),"\n",(0,i.jsx)(n.p,{children:"Always check if IPF converged to your tolerance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'result = balancer.adjust_io_matrix(io_matrix, new_outputs, new_inputs)\n\nif not result.converged:\n    print(f"\u26a0\ufe0f  Warning: IPF did not converge")\n    print(f"   Iterations: {result.iterations}")\n    print(f"   Final convergence rate: {result.convergence_rate:.2e}")\n    print(f"   Consider increasing max_iterations or relaxing convergence_rate")\nelse:\n    print(f"\u2713 IPF converged successfully in {result.iterations} iterations")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"constraint-verification",children:"Constraint Verification"}),"\n",(0,i.jsx)(n.p,{children:"Manually verify that constraints are satisfied:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def verify_constraints(result):\n    \\"\\"\\"Verify IPF constraints are satisfied.\\"\\"\\"\n    # Check row constraints\n    actual_rows = result.adjusted_matrix.sum(axis=1)\n    row_error = np.abs(actual_rows - result.row_constraints).max()\n    \n    # Check column constraints  \n    actual_cols = result.adjusted_matrix.sum(axis=0)\n    col_error = np.abs(actual_cols - result.col_constraints).max()\n    \n    print(f"Row constraint error: {row_error:.2e}")\n    print(f"Column constraint error: {col_error:.2e}")\n    \n    tolerance = 1e-5\n    if row_error < tolerance and col_error < tolerance:\n        print("\u2713 Constraints satisfied within tolerance")\n        return True\n    else:\n        print("\u2717 Constraints not satisfied")\n        return False\n\nverify_constraints(result)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"reasonableness-checks",children:"Reasonableness Checks"}),"\n",(0,i.jsx)(n.p,{children:"Check that adjusted values are reasonable:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def check_reasonableness(original, adjusted):\n    \\"\\"\\"Check if adjusted values are reasonable.\\"\\"\\"\n    # Check for negative values\n    if np.any(adjusted < 0):\n        print("\u26a0\ufe0f  Warning: Negative values in adjusted matrix")\n        return False\n    \n    # Check for extreme changes\n    change_ratios = adjusted / (original + 1e-12)  # Avoid division by zero\n    extreme_changes = np.any((change_ratios > 10) | (change_ratios < 0.1))\n    \n    if extreme_changes:\n        print("\u26a0\ufe0f  Warning: Extreme changes detected (>10x or <0.1x)")\n        print(f"Max ratio: {change_ratios.max():.2f}")\n        print(f"Min ratio: {change_ratios.min():.2f}")\n        return False\n    \n    # Check relative entropy (higher = more structural change)\n    if result.relative_entropy > 1.0:\n        print("\u26a0\ufe0f  Warning: High relative entropy indicates major structural change")\n        print(f"Relative entropy: {result.relative_entropy:.3f}")\n    \n    print("\u2713 Adjusted values appear reasonable")\n    return True\n\ncheck_reasonableness(result.original_matrix, result.adjusted_matrix)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,i.jsx)(n.h3,{id:"1-non-convergence",children:"1. Non-Convergence"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": IPF doesn't converge within the maximum iterations."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Increase ",(0,i.jsx)(n.code,{children:"max_iterations"})]}),"\n",(0,i.jsxs)(n.li,{children:["Relax ",(0,i.jsx)(n.code,{children:"convergence_rate"})," (use larger tolerance)"]}),"\n",(0,i.jsx)(n.li,{children:"Check if constraints are internally consistent"}),"\n",(0,i.jsx)(n.li,{children:"Verify input data quality"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# More permissive settings\nresult = balancer.adjust_io_matrix(\n    io_matrix, new_outputs, new_inputs,\n    max_iterations=5000,\n    convergence_rate=1e-4  # More permissive\n)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-inconsistent-constraints",children:"2. Inconsistent Constraints"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Row and column constraints don't balance properly."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Ensure total row sum equals total column sum:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'total_row_constraint = new_outputs.sum()\ntotal_col_constraint = new_inputs.sum()\n\nif abs(total_row_constraint - total_col_constraint) > 1e-10:\n    print(f"\u26a0\ufe0f  Warning: Row total ({total_row_constraint}) != Column total ({total_col_constraint})")\n    # Adjust one to match the other\n    new_inputs = new_inputs * (total_row_constraint / total_col_constraint)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-zero-structure-issues",children:"3. Zero Structure Issues"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Preserving zero structure conflicts with constraint satisfaction."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Use ",(0,i.jsx)(n.code,{children:"preserve_structure=False"})," for more flexible adjustment:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"result = balancer.adjust_a_matrix(\n    A_matrix, new_outputs, \n    preserve_structure=False  # Allow filling of zero elements\n)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-numerical-precision",children:"4. Numerical Precision"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Very small or very large numbers cause precision issues."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Scale your data appropriately:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Scale data to reasonable range\nscaled_matrix = original_matrix / original_matrix.mean()\n# ... apply IPF ...\n# Scale back\nresult.adjusted_matrix = result.adjusted_matrix * original_matrix.mean()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Always validate convergence"})," - Check ",(0,i.jsx)(n.code,{children:"result.converged"})," and convergence metrics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Verify constraints"})," - Manually check that constraints are satisfied"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor reasonableness"})," - Watch for extreme changes or negative values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use appropriate tolerance"})," - Balance precision with computational efficiency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preserve structure when appropriate"})," - Use ",(0,i.jsx)(n.code,{children:"preserve_structure=True"})," for A matrices"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Document scenarios clearly"})," - Keep track of what each scenario represents"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test with simple cases"})," - Validate your approach with known examples first"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-other-fastspa-features",children:"Integration with Other FastSPA Features"}),"\n",(0,i.jsx)(n.p,{children:"IPF integrates seamlessly with other FastSPA functionality:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SPA Analysis"}),": Use adjusted A matrices and satellite data for pathway analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concordance"}),": Combine IPF with sector mapping for cross-classification adjustments"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visualization"}),": Apply FastSPA plotting functions to scenario results"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-satellite"}),": Balance multiple environmental accounts consistently"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more advanced use cases, explore the ",(0,i.jsx)(n.a,{href:"/docs/api/ipf",children:"IPF API reference"})," and example scripts in the ",(0,i.jsx)(n.code,{children:"examples/"})," directory."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8193(e,n,s){s.d(n,{R:()=>r,x:()=>o});var t=s(758);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);